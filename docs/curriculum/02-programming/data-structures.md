# Data Structures

## Required Hours
- **Total Hours**: 30 hours
- **Session Pattern**: 8 sessions of 4 hours

## Purpose

Data structures organize and store data efficiently, enabling programs to access and modify information effectively. Choosing the right data structure is crucial for writing performant, maintainable code. This module covers fundamental data structures used in everyday programming.

## Learning Outcomes

Students will be able to:

- Understand the characteristics and use cases of common data structures
- Implement and manipulate arrays, lists, stacks, queues, and hash tables
- Choose appropriate data structures for specific problems
- Analyze time and space complexity of data structure operations
- Apply data structures to solve real-world programming challenges

## Core Content

### Arrays and Lists

Sequential collections of elements:

**Arrays**:
- Fixed-size collections
- Efficient random access by index
- Contiguous memory allocation
- Common operations: access, update, traverse

**Dynamic Lists**:
- Variable-size collections
- Growing and shrinking as needed
- Common operations: append, insert, remove, search
- Implementation considerations

### Strings

Specialized sequences of characters:

- String representation and storage
- Immutability in many languages
- Common operations: concatenation, substring, search, replace
- String manipulation techniques
- Unicode and character encoding

### Stacks

Last-In-First-Out (LIFO) data structure:

- Push: Add to top
- Pop: Remove from top
- Peek: View top without removing
- Use cases: function call stack, undo functionality, parsing
- Implementation using arrays or linked lists

### Queues

First-In-First-Out (FIFO) data structure:

- Enqueue: Add to back
- Dequeue: Remove from front
- Peek: View front without removing
- Use cases: task scheduling, breadth-first search, buffering
- Variations: priority queues, circular queues

### Hash Tables / Dictionaries

Key-value pair storage:

- Fast lookup by key
- Hash functions and collision handling
- Common operations: insert, lookup, delete
- Use cases: caching, counting, indexing
- Performance characteristics

### Sets

Collections of unique elements:

- No duplicate values
- Fast membership testing
- Set operations: union, intersection, difference
- Use cases: removing duplicates, membership testing
- Implementation approaches

### Linked Lists

Node-based sequential structures:

**Singly Linked Lists**:
- Each node points to next
- Efficient insertion and deletion
- Sequential access only

**Doubly Linked Lists**:
- Nodes point to both next and previous
- Bidirectional traversal
- More complex but more flexible

### Trees (Introduction)

Hierarchical data structures:

- **Binary Trees**: Each node has up to two children
- **Tree Terminology**: Root, parent, child, leaf, depth, height
- **Tree Traversal**: Inorder, preorder, postorder
- **Use Cases**: File systems, organization charts, decision trees
- **Basic Operations**: Insert, search, delete

### Choosing Data Structures

Selecting the right tool for the job:

- **Access Patterns**: Sequential vs random access
- **Performance Requirements**: Time vs space tradeoffs
- **Operation Frequency**: Which operations are most common
- **Data Characteristics**: Size, uniqueness, ordering
- **Problem Constraints**: Memory limits, speed requirements

### Big O Notation (Introduction)

Understanding algorithm efficiency:

- **Time Complexity**: How runtime scales with input size
- **Space Complexity**: How memory usage scales
- **Common Complexities**: O(1), O(n), O(log n), O(nÂ²)
- **Best, Average, Worst Cases**: Different scenarios
- **Practical Implications**: Choosing efficient approaches

## Deliverables

- Implementations of core data structures
- Programs solving problems with appropriate data structures
- Performance analysis comparing different approaches
- Documentation explaining data structure choices
- Portfolio demonstrating understanding of efficiency tradeoffs
